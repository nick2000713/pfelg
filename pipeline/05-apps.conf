# 05-apps.conf
################################################################################
# Based on official pfELK v24.09 - Adapted for Docker                         #
################################################################################

filter {
  if "pfelk" in [tags] {
    ### captive portal ###
    if [log][syslog][appname] =~ /^logportalauth/ {
      mutate { replace => { "[log][syslog][appname]" => "captiveportal" } }
    }
    if [log][syslog][appname] =~ /^captiveportal/ {
      mutate {
        add_tag => "captive"
        add_field => { "[event][dataset]" => "pfelk.captive" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{CAPTIVEPORTAL}"]
      }
    }

    ### dhcpd ###
    if [log][syslog][appname] =~ /^dhcpd$/ {
      mutate {
        add_tag => ["dhcp", "dhcpdv4"]
        add_field => { "[event][dataset]" => "pfelk.dhcp" }
        replace => { "[log][syslog][appname]" => "dhcp" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{DHCPD}"]
      }
    }

    ### dpinger ###
    if [log][syslog][appname] =~ /^dpinger/ {
      mutate {
        add_tag => "dpinger"
        add_field => { "[event][dataset]" => "pfelk.dpinger" }
      }
    }

    ### haproxy ###
    if [log][syslog][appname] =~ /^haproxy/ {
      mutate {
        add_tag => "haproxy"
        add_field => { "[event][dataset]" => "pfelk.haproxy" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{HAPROXY}"]
      }
    }

    ### kea-dhcp4 ###
    if [log][syslog][appname] =~ /^kea-dhcp4$/ {
      mutate {
        add_tag => ["kea-dhcp", "dhcp4"]
        add_field => { "[event][dataset]" => "pfelk.kea-dhcp4" }
        replace => { "[log][syslog][appname]" => "kea-dhcp" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{KEADHCP4}"]
      }
    }

    ### nginx ###
    if [log][syslog][appname] =~ /^nginx/ {
      mutate {
        add_tag => "nginx"
        add_field => { "[event][dataset]" => "pfelk.nginx" }
        replace => { "[log][syslog][appname]" => "nginx" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => { "filter_message" => "%{NGINX}" }
      }
    }

    ### openvpn ###
    if [log][syslog][appname] =~ /^openvpn/ {
      mutate {
        add_tag => "openvpn"
        add_field => { "[event][dataset]" => "pfelk.openvpn" }
        replace => { "[log][syslog][appname]" => "openvpn" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{OPENVPN}"]
      }
    }

    ### ntpd ###
    if [log][syslog][appname] =~ /^ntpd/ {
      mutate {
        add_tag => "ntpd"
        add_field => { "[event][dataset]" => "pfelk.ntpd" }
      }
    }

    ### php-fpm (web portal) ###
    if [log][syslog][appname] =~ /^php-fpm/ {
      mutate {
        add_tag => "web_portal"
        add_field => { "[event][dataset]" => "pfelk.webportal" }
      }
    }

    ### snort ###
    if [log][syslog][appname] =~ /^snort/ {
      mutate {
        add_tag => "snort"
        add_field => { "[event][dataset]" => "pfelk.snort" }
        add_field => { "[event][category]" => "intrusion_detection" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{SNORT}"]
      }
    }

    ### suricata ###
    if [log][syslog][appname] =~ /^suricata$/ {
      if [filter_message] =~ /^\{.*\}$/ {
        json {
          source => "filter_message"
          target => "[suricata][eve]"
          add_tag => "suricata_json"
        }
        if [suricata][eve][src_ip] {
          mutate { add_field => { "[source][ip]" => "%{[suricata][eve][src_ip]}" } }
        }
        if [suricata][eve][dest_ip] {
          mutate { add_field => { "[destination][ip]" => "%{[suricata][eve][dest_ip]}" } }
        }
        if [suricata][eve][src_port] {
          mutate { add_field => { "[source][port]" => "%{[suricata][eve][src_port]}" } }
        }
        if [suricata][eve][dest_port] {
          mutate { add_field => { "[destination][port]" => "%{[suricata][eve][dest_port]}" } }
        }
      }
      if "suricata_json" not in [tags] {
        grok {
          patterns_dir => ["/usr/share/logstash/patterns"]
          match => ["filter_message", "%{SURICATA}"]
        }
      }
      mutate {
        remove_tag => ["suricata_json"]
        add_tag => "suricata"
        add_field => { "[event][dataset]" => "pfelk.suricata" }
      }
    }

    ### squid ###
    if [log][syslog][appname] == "(squid-1)" {
      mutate {
        replace => { "[log][syslog][appname]" => "squid" }
        add_field => { "[event][dataset]" => "pfelk.squid" }
        add_tag => "squid"
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{SQUID}"]
      }
    }

    ### unbound ###
    if [log][syslog][appname] =~ /^unbound/ {
      mutate {
        add_tag => "unbound"
        add_field => { "[event][dataset]" => "pfelk.unbound" }
      }
      grok {
        patterns_dir => ["/usr/share/logstash/patterns"]
        match => ["filter_message", "%{UNBOUND}"]
      }
      # Extract registered domain
      grok {
        match => ["[dns][question][name]", "(\.)?(?<[dns][question][registered_domain]>[^.]+\.[^.]+)$"]
        tag_on_failure => []
      }
    }
  }
}
